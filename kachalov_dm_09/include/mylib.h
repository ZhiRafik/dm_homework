#ifndef MYLIB_H
#define MYLIB_H

#include <stddef.h>

// Внутреннее представление графа:
// n — количество вершин;
// deg[i] — текущая степень вершины i;
// cap[i] — текущая ёмкость списка смежности вершины i;
// adj[i] — динамический массив соседей вершины i 
typedef struct graph {
    size_t n;
    size_t *deg;
    size_t *cap;
    int **adj;
} graph_t;

// Создать граф с vertex_count вершинами (0 .. vertex_count - 1)
// Возвращает указатель на граф или NULL при ошибке выделения памяти
graph_t *graph_create(size_t vertex_count);

// Освободить всю память, занятую графом
void graph_free(graph_t *g);

// Добавить неориентированное ребро (u, v)
// Не добавляет кратное ребро и петлю (u == v)
// Возвращает:
//   0  при успехе;
//  -1  при выходе индекса вершины за пределы;
//  -2  при ошибке выделения памяти
int graph_add_edge(graph_t *g, size_t u, size_t v);

// Проверка существования ребра (u, v) в графе
// Возвращает 1, если ребро есть, 0 — если нет или индексы некорректны
int graph_has_edge(const graph_t *g, size_t u, size_t v);

// Количество вершин в графе
size_t graph_vertex_count(const graph_t *g);

// Степень вершины v
// При некорректном индексе возвращает 0
size_t graph_degree(const graph_t *g, size_t v);

// Упрощение графа
// Пока в графе существует вершина v степени 2 с соседями u и w,
// вершина v и инцидентные ей рёбра (u, v) и (v, w) удаляются,
// а вместо них добавляется одно ребро (u, w), если его ещё нет
// Вершина v после операции становится изолированной (степень 0)
void graph_simplify(graph_t *g);

// Печать графа (списки смежности)
void print_graph(const graph_t *g);

#endif